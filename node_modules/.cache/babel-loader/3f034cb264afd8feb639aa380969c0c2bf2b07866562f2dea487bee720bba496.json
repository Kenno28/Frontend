{"ast":null,"code":"var _jsxFileName = \"/Users/melisazor/Desktop/Dropbox/Semester 3/Web II/we2.blatt12/src/backend/fetchWithErrorHandling.tsx\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// istanbul ignore file\n\n/**\r\n * Funktioniert wie fetch, erkennt aber auch Validierungsfehler und HTML-Antworten und\r\n * wandelt diese in geworfene Errors (ErrorFromValidation und ErrorWithHTML) um.\r\n * \r\n * D.h. statt\r\n * ```\r\n * const response = await fetch(url, init);\r\n * const data: DataType = await response.json();\r\n * return data;\r\n * ```\r\n * schreibt man\r\n * ```\r\n * const response = await fetchWithErrorHandling(url, init);\r\n * const data: DataType = await response.json();\r\n * return data;\r\n * ```\r\n * \r\n * Falls die Antwort ein Validierungsfehler ist (Status 400), wird eine Exception vom Typ `ErrorFromValidation` geworfen.\r\n * Falls die Antwort ein HTML-Dokument ist (Status 404/500), wird eine Exception vom Typ `ErrorWithHTML` geworfen.\r\n * \r\n * Sowohl `ErrorFromValidation` als auch `ErrorWithHTML` sind von Error abgeleitet,\r\n * haben eine zusätzliche Eigenschaft `status`\r\n * und können in der Komponente, die im Fehlerfall angezeigt wird, verwendet werden, um den Fehler genauer anzuzeigen.\r\n * In `ErrorWithHTML` ist die HTML-Antwort in `html` gespeichert,\r\n * in `ErrorFromValidation` die Fehlermeldungen in `validationErrors`\r\n * \r\n * *Hinweis für Tests*: Ob die Antwort in Ordnung ist oder nicht, wird an dem Property `ok` der Response erkannt.\r\n */\nexport async function fetchWithErrorHandling(url, init) {\n  var _response$headers$get;\n  const response = await fetch(url, init);\n  const contentType = (_response$headers$get = response.headers.get(\"Content-Type\")) !== null && _response$headers$get !== void 0 ? _response$headers$get : \"\";\n  if (!response.ok) {\n    if (contentType.startsWith(\"application/json\")) {\n      const data = await response.json();\n      if (data.errors instanceof Array) {\n        const validationErrors = data.errors;\n        throw new ErrorFromValidation(response.status, validationErrors);\n      }\n    } else if (contentType.startsWith(\"text/html\")) {\n      const html = await response.text();\n      throw new ErrorWithHTML(response.status, html);\n    } else if (contentType.startsWith(\"text/plain\")) {\n      const text = await response.text();\n      throw new Error(`Status ${response.status}: ${text}`);\n    }\n  }\n  return response;\n}\n\n/**\r\n * ValidationError created by express-validator (without nested errors).\r\n */\n\nexport class ErrorFromValidation extends Error {\n  static msg(validationErrors) {\n    if (validationErrors.length === 0) {\n      return \"Unspecified validation error\";\n    }\n    return validationErrors.map(validationError => {\n      return `${validationError.msg} (${validationError.location} ${validationError.path}, value ${validationError.value})`;\n    }).join(\". \");\n  }\n  constructor(status, validationErrors) {\n    super(ErrorFromValidation.msg(validationErrors));\n    this.param = void 0;\n    this.status = void 0;\n    this.validationErrors = void 0;\n    this.status = status;\n    this.validationErrors = validationErrors;\n  }\n}\nexport class ErrorWithHTML extends Error {\n  constructor(status, html) {\n    super(\"Error\");\n    this.div = void 0;\n    this.status = void 0;\n    this.status = status;\n    let bodyStart = html.indexOf(\"<body\");\n    if (bodyStart >= 0) {\n      bodyStart = html.indexOf(\">\", bodyStart);\n    }\n    const bodyEnd = html.indexOf(\"</body>\", bodyStart);\n    if (bodyStart >= 0 && bodyEnd >= 0) {\n      html = html.substring(bodyStart + 1, bodyEnd);\n    }\n    // An dem Namen sieht man schon: es ist gefährlich und sollte im Allgemeinen nicht verwendet werden.\n    // Auf diese Art macht man sich für XSS-Angriffe verwundbar. Wir machen das hier trotzdem,\n    // einmal um zu demonstrieren, wie man es nicht macht, und um die Fehler für die Entwicklung schön anzuzeigen.\n    // In echten Anwendungen würde man Fehler ohnehin niemals so anzeigen.\n    this.div = /*#__PURE__*/_jsxDEV(\"div\", {\n      dangerouslySetInnerHTML: {\n        __html: html\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 20\n    });\n  }\n}","map":{"version":3,"names":["fetchWithErrorHandling","url","init","_response$headers$get","response","fetch","contentType","headers","get","ok","startsWith","data","json","errors","Array","validationErrors","ErrorFromValidation","status","html","text","ErrorWithHTML","Error","msg","length","map","validationError","location","path","value","join","constructor","param","div","bodyStart","indexOf","bodyEnd","substring","_jsxDEV","dangerouslySetInnerHTML","__html","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/Users/melisazor/Desktop/Dropbox/Semester 3/Web II/we2.blatt12/src/backend/fetchWithErrorHandling.tsx"],"sourcesContent":["// istanbul ignore file\r\n\r\n/**\r\n * Funktioniert wie fetch, erkennt aber auch Validierungsfehler und HTML-Antworten und\r\n * wandelt diese in geworfene Errors (ErrorFromValidation und ErrorWithHTML) um.\r\n * \r\n * D.h. statt\r\n * ```\r\n * const response = await fetch(url, init);\r\n * const data: DataType = await response.json();\r\n * return data;\r\n * ```\r\n * schreibt man\r\n * ```\r\n * const response = await fetchWithErrorHandling(url, init);\r\n * const data: DataType = await response.json();\r\n * return data;\r\n * ```\r\n * \r\n * Falls die Antwort ein Validierungsfehler ist (Status 400), wird eine Exception vom Typ `ErrorFromValidation` geworfen.\r\n * Falls die Antwort ein HTML-Dokument ist (Status 404/500), wird eine Exception vom Typ `ErrorWithHTML` geworfen.\r\n * \r\n * Sowohl `ErrorFromValidation` als auch `ErrorWithHTML` sind von Error abgeleitet,\r\n * haben eine zusätzliche Eigenschaft `status`\r\n * und können in der Komponente, die im Fehlerfall angezeigt wird, verwendet werden, um den Fehler genauer anzuzeigen.\r\n * In `ErrorWithHTML` ist die HTML-Antwort in `html` gespeichert,\r\n * in `ErrorFromValidation` die Fehlermeldungen in `validationErrors`\r\n * \r\n * *Hinweis für Tests*: Ob die Antwort in Ordnung ist oder nicht, wird an dem Property `ok` der Response erkannt.\r\n */\r\nexport async function fetchWithErrorHandling(url: string, init?: RequestInit): Promise<Response> {\r\n\r\n    const response: Response = await fetch(url, init);\r\n\r\n    const contentType = response.headers.get(\"Content-Type\") ?? \"\";\r\n    if (!response.ok) {\r\n        if (contentType.startsWith(\"application/json\")) {\r\n            const data = await response.json()\r\n            if (data.errors instanceof Array) {\r\n                const validationErrors = data.errors as ValidationError[];\r\n                throw new ErrorFromValidation(response.status, validationErrors);\r\n            }\r\n        } else if (contentType.startsWith(\"text/html\")) {\r\n            const html = await response.text();\r\n            throw new ErrorWithHTML(response.status, html);\r\n        } else if (contentType.startsWith(\"text/plain\")) {\r\n            const text = await response.text();\r\n            throw new Error(`Status ${response.status}: ${text}`);\r\n        }\r\n    }\r\n\r\n    return response;\r\n}\r\n\r\n/**\r\n * ValidationError created by express-validator (without nested errors).\r\n */\r\nexport type ValidationError = {\r\n    /** Fehlerbeschreibung */\r\n    msg: string;\r\n    /** \r\n     * Pfad zu dem Property innerhalb der Location, in der Regel einfach das Property das \r\n     * im dem der Fehler auftrat.\r\n     */\r\n    path: string;\r\n    /**\r\n     * Ort innerhalb des Requests, also z.B. \"body\" oder \"params\".\r\n     */\r\n    location: string;\r\n    /**\r\n     * Wert des Properties, also in der Regel der Wert, der den Fehler verursacht hat.\r\n     */\r\n    value: string;\r\n}\r\n\r\nexport class ErrorFromValidation extends Error {\r\n    param: string | undefined;\r\n    status: number;\r\n    validationErrors: ValidationError[];\r\n\r\n    private static msg(validationErrors: ValidationError[]): string {\r\n        if (validationErrors.length === 0) {\r\n            return \"Unspecified validation error\";\r\n        }\r\n        return validationErrors.map((validationError) => {\r\n            return `${validationError.msg} (${validationError.location} ${validationError.path}, value ${validationError.value})`;\r\n        }).join(\". \");\r\n    }\r\n\r\n    constructor(status: number, validationErrors: ValidationError[]) {\r\n        super(ErrorFromValidation.msg(validationErrors));\r\n        this.status = status;\r\n        this.validationErrors = validationErrors;\r\n    }\r\n}\r\n\r\nexport class ErrorWithHTML extends Error {\r\n    div: JSX.Element;\r\n    status: number;\r\n\r\n    constructor(status: number, html: string) {\r\n        super(\"Error\");\r\n        this.status = status;\r\n        let bodyStart = html.indexOf(\"<body\");\r\n        if (bodyStart >= 0) {\r\n            bodyStart = html.indexOf(\">\", bodyStart);\r\n        }\r\n        const bodyEnd = html.indexOf(\"</body>\", bodyStart);\r\n        if (bodyStart >= 0 && bodyEnd >= 0) {\r\n            html = html.substring(bodyStart + 1, bodyEnd);\r\n        }\r\n        // An dem Namen sieht man schon: es ist gefährlich und sollte im Allgemeinen nicht verwendet werden.\r\n        // Auf diese Art macht man sich für XSS-Angriffe verwundbar. Wir machen das hier trotzdem,\r\n        // einmal um zu demonstrieren, wie man es nicht macht, und um die Fehler für die Entwicklung schön anzuzeigen.\r\n        // In echten Anwendungen würde man Fehler ohnehin niemals so anzeigen.\r\n        this.div = <div dangerouslySetInnerHTML={{__html: html}} />;\r\n    }\r\n}\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}