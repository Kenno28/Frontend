{"ast":null,"code":"import{jsx as _jsx}from\"react/jsx-runtime\";// istanbul ignore file\n/**\r\n * Funktioniert wie fetch, erkennt aber auch Validierungsfehler und HTML-Antworten und\r\n * wandelt diese in geworfene Errors (ErrorFromValidation und ErrorWithHTML) um.\r\n * \r\n * D.h. statt\r\n * ```\r\n * const response = await fetch(url, init);\r\n * const data: DataType = await response.json();\r\n * return data;\r\n * ```\r\n * schreibt man\r\n * ```\r\n * const response = await fetchWithErrorHandling(url, init);\r\n * const data: DataType = await response.json();\r\n * return data;\r\n * ```\r\n * \r\n * Falls die Antwort ein Validierungsfehler ist (Status 400), wird eine Exception vom Typ `ErrorFromValidation` geworfen.\r\n * Falls die Antwort ein HTML-Dokument ist (Status 404/500), wird eine Exception vom Typ `ErrorWithHTML` geworfen.\r\n * \r\n * Sowohl `ErrorFromValidation` als auch `ErrorWithHTML` sind von Error abgeleitet,\r\n * haben eine zusätzliche Eigenschaft `status`\r\n * und können in der Komponente, die im Fehlerfall angezeigt wird, verwendet werden, um den Fehler genauer anzuzeigen.\r\n * In `ErrorWithHTML` ist die HTML-Antwort in `html` gespeichert,\r\n * in `ErrorFromValidation` die Fehlermeldungen in `validationErrors`\r\n * \r\n * *Hinweis für Tests*: Ob die Antwort in Ordnung ist oder nicht, wird an dem Property `ok` der Response erkannt.\r\n */export async function fetchWithErrorHandling(url,init){var _response$headers$get;const response=await fetch(url,init);const contentType=(_response$headers$get=response.headers.get(\"Content-Type\"))!==null&&_response$headers$get!==void 0?_response$headers$get:\"\";if(!response.ok){if(contentType.startsWith(\"application/json\")){const data=await response.json();if(data.errors instanceof Array){const validationErrors=data.errors;throw new ErrorFromValidation(response.status,validationErrors);}}else if(contentType.startsWith(\"text/html\")){const html=await response.text();throw new ErrorWithHTML(response.status,html);}else if(contentType.startsWith(\"text/plain\")){const text=await response.text();throw new Error(\"Status \".concat(response.status,\": \").concat(text));}}return response;}/**\r\n * ValidationError created by express-validator (without nested errors).\r\n */export class ErrorFromValidation extends Error{static msg(validationErrors){if(validationErrors.length===0){return\"Unspecified validation error\";}return validationErrors.map(validationError=>{return\"\".concat(validationError.msg,\" (\").concat(validationError.location,\" \").concat(validationError.path,\", value \").concat(validationError.value,\")\");}).join(\". \");}constructor(status,validationErrors){super(ErrorFromValidation.msg(validationErrors));this.param=void 0;this.status=void 0;this.validationErrors=void 0;this.status=status;this.validationErrors=validationErrors;}}export class ErrorWithHTML extends Error{constructor(status,html){super(\"Error\");this.div=void 0;this.status=void 0;this.status=status;let bodyStart=html.indexOf(\"<body\");if(bodyStart>=0){bodyStart=html.indexOf(\">\",bodyStart);}const bodyEnd=html.indexOf(\"</body>\",bodyStart);if(bodyStart>=0&&bodyEnd>=0){html=html.substring(bodyStart+1,bodyEnd);}// An dem Namen sieht man schon: es ist gefährlich und sollte im Allgemeinen nicht verwendet werden.\n// Auf diese Art macht man sich für XSS-Angriffe verwundbar. Wir machen das hier trotzdem,\n// einmal um zu demonstrieren, wie man es nicht macht, und um die Fehler für die Entwicklung schön anzuzeigen.\n// In echten Anwendungen würde man Fehler ohnehin niemals so anzeigen.\nthis.div=/*#__PURE__*/_jsx(\"div\",{dangerouslySetInnerHTML:{__html:html}});}}","map":{"version":3,"names":["fetchWithErrorHandling","url","init","_response$headers$get","response","fetch","contentType","headers","get","ok","startsWith","data","json","errors","Array","validationErrors","ErrorFromValidation","status","html","text","ErrorWithHTML","Error","concat","msg","length","map","validationError","location","path","value","join","constructor","param","div","bodyStart","indexOf","bodyEnd","substring","_jsx","dangerouslySetInnerHTML","__html"],"sources":["C:/Users/erayz/Dropbox/Semester 3/Web II/we2.blatt12/src/backend/fetchWithErrorHandling.tsx"],"sourcesContent":["// istanbul ignore file\r\n\r\n/**\r\n * Funktioniert wie fetch, erkennt aber auch Validierungsfehler und HTML-Antworten und\r\n * wandelt diese in geworfene Errors (ErrorFromValidation und ErrorWithHTML) um.\r\n * \r\n * D.h. statt\r\n * ```\r\n * const response = await fetch(url, init);\r\n * const data: DataType = await response.json();\r\n * return data;\r\n * ```\r\n * schreibt man\r\n * ```\r\n * const response = await fetchWithErrorHandling(url, init);\r\n * const data: DataType = await response.json();\r\n * return data;\r\n * ```\r\n * \r\n * Falls die Antwort ein Validierungsfehler ist (Status 400), wird eine Exception vom Typ `ErrorFromValidation` geworfen.\r\n * Falls die Antwort ein HTML-Dokument ist (Status 404/500), wird eine Exception vom Typ `ErrorWithHTML` geworfen.\r\n * \r\n * Sowohl `ErrorFromValidation` als auch `ErrorWithHTML` sind von Error abgeleitet,\r\n * haben eine zusätzliche Eigenschaft `status`\r\n * und können in der Komponente, die im Fehlerfall angezeigt wird, verwendet werden, um den Fehler genauer anzuzeigen.\r\n * In `ErrorWithHTML` ist die HTML-Antwort in `html` gespeichert,\r\n * in `ErrorFromValidation` die Fehlermeldungen in `validationErrors`\r\n * \r\n * *Hinweis für Tests*: Ob die Antwort in Ordnung ist oder nicht, wird an dem Property `ok` der Response erkannt.\r\n */\r\nexport async function fetchWithErrorHandling(url: string, init?: RequestInit): Promise<Response> {\r\n\r\n    const response: Response = await fetch(url, init);\r\n\r\n    const contentType = response.headers.get(\"Content-Type\") ?? \"\";\r\n    if (!response.ok) {\r\n        if (contentType.startsWith(\"application/json\")) {\r\n            const data = await response.json()\r\n            if (data.errors instanceof Array) {\r\n                const validationErrors = data.errors as ValidationError[];\r\n                throw new ErrorFromValidation(response.status, validationErrors);\r\n            }\r\n        } else if (contentType.startsWith(\"text/html\")) {\r\n            const html = await response.text();\r\n            throw new ErrorWithHTML(response.status, html);\r\n        } else if (contentType.startsWith(\"text/plain\")) {\r\n            const text = await response.text();\r\n            throw new Error(`Status ${response.status}: ${text}`);\r\n        }\r\n    }\r\n\r\n    return response;\r\n}\r\n\r\n/**\r\n * ValidationError created by express-validator (without nested errors).\r\n */\r\nexport type ValidationError = {\r\n    /** Fehlerbeschreibung */\r\n    msg: string;\r\n    /** \r\n     * Pfad zu dem Property innerhalb der Location, in der Regel einfach das Property das \r\n     * im dem der Fehler auftrat.\r\n     */\r\n    path: string;\r\n    /**\r\n     * Ort innerhalb des Requests, also z.B. \"body\" oder \"params\".\r\n     */\r\n    location: string;\r\n    /**\r\n     * Wert des Properties, also in der Regel der Wert, der den Fehler verursacht hat.\r\n     */\r\n    value: string;\r\n}\r\n\r\nexport class ErrorFromValidation extends Error {\r\n    param: string | undefined;\r\n    status: number;\r\n    validationErrors: ValidationError[];\r\n\r\n    private static msg(validationErrors: ValidationError[]): string {\r\n        if (validationErrors.length === 0) {\r\n            return \"Unspecified validation error\";\r\n        }\r\n        return validationErrors.map((validationError) => {\r\n            return `${validationError.msg} (${validationError.location} ${validationError.path}, value ${validationError.value})`;\r\n        }).join(\". \");\r\n    }\r\n\r\n    constructor(status: number, validationErrors: ValidationError[]) {\r\n        super(ErrorFromValidation.msg(validationErrors));\r\n        this.status = status;\r\n        this.validationErrors = validationErrors;\r\n    }\r\n}\r\n\r\nexport class ErrorWithHTML extends Error {\r\n    div: JSX.Element;\r\n    status: number;\r\n\r\n    constructor(status: number, html: string) {\r\n        super(\"Error\");\r\n        this.status = status;\r\n        let bodyStart = html.indexOf(\"<body\");\r\n        if (bodyStart >= 0) {\r\n            bodyStart = html.indexOf(\">\", bodyStart);\r\n        }\r\n        const bodyEnd = html.indexOf(\"</body>\", bodyStart);\r\n        if (bodyStart >= 0 && bodyEnd >= 0) {\r\n            html = html.substring(bodyStart + 1, bodyEnd);\r\n        }\r\n        // An dem Namen sieht man schon: es ist gefährlich und sollte im Allgemeinen nicht verwendet werden.\r\n        // Auf diese Art macht man sich für XSS-Angriffe verwundbar. Wir machen das hier trotzdem,\r\n        // einmal um zu demonstrieren, wie man es nicht macht, und um die Fehler für die Entwicklung schön anzuzeigen.\r\n        // In echten Anwendungen würde man Fehler ohnehin niemals so anzeigen.\r\n        this.div = <div dangerouslySetInnerHTML={{__html: html}} />;\r\n    }\r\n}\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}